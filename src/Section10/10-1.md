# 상속
<br>

## 1. 상속 관계
***! key point***
1. 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용 한다. (extends)
2. 상속 받을 대상은 `하나만` 선택할 수 있다.
3. 자바는 `다중상속`을 허용하지만 `단일상속`만을 허용한다. (ex : 자식 클래스가 여러 부모 클래스를 상속받을 수는 없지만 부모의 부모에게 상속받을 수는 있다.)
4. 대신, 인터페이스를 사용하면 다중 `구현`이 가능하다.

## 2. 상속과 메모리 구조
***! key point***
1. 상속받은 자식 클래스는 `참조값은 하나`이지만 부모 클래스의 정보를 포함하여 인스턴스를 생성한다.
2. 메모리 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.
3. 부모 클래스의 메서드가 자식 클래스의 메서드에도 존재하는 경우, 자식 클래스의 메서드가 부모 클래스의 메서드를 덮어쓴다. (재정의, 오버라이딩)
4. 부모 클래스의 메서드가 자식 클래스의 메서드에 없는 경우, 부모 클래스의 메서드를 사용한다.

## 3. 상속과 메서드 오버라이딩
***! key point***
1. @override 어노테이션을 사용하여 메서드 오버라이딩을 명시적으로 표현할 수 있다.
<br> 어노테이션을 명시하면, 오버라이딩 조건을 만족하지 않았을 때 컴파일 에러를 발생시킨다. (단, 필수는 아님)

***! 메서드 오버라이딩의 조건***
1. 기본적으로 `부모 메서드와 같은 메서드를 오버라이딩 할 수 있다.` (메서드 이름, 메서드 매개변수, 반환 타입)
2. 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적일 수 없다.
<br>예를들어, 상위 클래스의 메서드가 protected 키워드로 선언된 메서드일 때,
<br>하위 클래스에서 오버라이딩 하는 메서드는 그보다 더 제한적인 private 키워드로 선언할 수 없다.
3. 오버라이딩 메서드는 부모 클래스보다 더 많은 예외를 throw 할 수 없다.
4. static, final, private 키워드가 붙은 메서드는 오버라이딩 할 수 없다.
<br>final - 수정할 수 없음.  static - 의미가 없음.  private - 해당 클래스에서만 접근할 수 있음. (하위 클래스에서 접근 불가)
5. 생성자(Constructor)는 오버라이딩 할 수 없다.

## 4. 상속과 접근제어
***접근제어자***

private < default < protected < public

## 5. super
***! Key point***
1. 상속받은 메서드에서 super 라는 키워드를 사용해 부모 클래스를 호출할 수 있다.
2. 상속 관계의 인스턴스를 생성하면 자식과 부모 클래스가 각각 다 만들어지기 떄문이다.
3. 상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 명시해 주어야 한다.
<br>단, 기본 생성자 인 경우 생략가능
4. 기본 생성자가 아닌 경우 super 에 인자를 할당해주어야 한다.
5. 요점은 *자식 인스턴스가 만들어지기 위해서는 부모 인스턴스가 만들어져야 한다* 를 기억하면 된다.


## !!! 문제와 풀이
### 문제 1 : 상속 관계 상품
***Q. 쇼핑몰의 판매 상품을 만들어보자***
- Book, Album, Movie 이렇게 3가지 상품을 클래스로 만들어야 한다.
- 코드 중복이 없게 상속 관계를 사용하자. 부모 클래스는 Item 이라는 이름을 사용한다.
- 공통 속성 : name, price
- 공통 메서드 : getPrice, print
  - Book : 저자(author), isbn(isbn)
  - Album : 아티스트(artist)
  - Movie : 감독(director), 배우(actor)

***코드 작성 전 예상 풀이***

1. Item 클래스에 공통 속성, 메서드를 정의하고 extends <br>
2. 각자 필요한 print 메서드에 @override















