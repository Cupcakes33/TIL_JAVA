# 상속
<br>

## 1. 상속 관계
***! key point***
1. 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용 한다. (extends)
2. 상속 받을 대상은 `하나만` 선택할 수 있다.
3. 자바는 `다중상속`을 허용하지만 `단일상속`만을 허용한다. (ex : 자식 클래스가 여러 부모 클래스를 상속받을 수는 없지만 부모의 부모에게 상속받을 수는 있다.)
4. 대신, 인터페이스를 사용하면 다중 `구현`이 가능하다.

## 2. 상속과 메모리 구조
***! key point***
1. 상속받은 자식 클래스는 `참조값은 하나`이지만 부모 클래스의 정보를 포함하여 인스턴스를 생성한다.
2. 메모리 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.
3. 부모 클래스의 메서드가 자식 클래스의 메서드에도 존재하는 경우, 자식 클래스의 메서드가 부모 클래스의 메서드를 덮어쓴다. (재정의, 오버라이딩)
4. 부모 클래스의 메서드가 자식 클래스의 메서드에 없는 경우, 부모 클래스의 메서드를 사용한다.

## 3. 상속과 메서드 오버라이딩
***! key point***
1. @override 어노테이션을 사용하여 메서드 오버라이딩을 명시적으로 표현할 수 있다.
<br> 어노테이션을 명시하면, 오버라이딩 조건을 만족하지 않았을 때 컴파일 에러를 발생시킨다. (단, 필수는 아님)

***! 메서드 오버라이딩의 조건***
1. 기본적으로 `부모 메서드와 같은 메서드를 오버라이딩 할 수 있다.` (메서드 이름, 메서드 매개변수, 반환 타입)
2. 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적일 수 없다.
<br>예를들어, 상위 클래스의 메서드가 protected 키워드로 선언된 메서드일 때,
<br>하위 클래스에서 오버라이딩 하는 메서드는 그보다 더 제한적인 private 키워드로 선언할 수 없다.
3. 오버라이딩 메서드는 부모 클래스보다 더 많은 예외를 throw 할 수 없다.
4. static, final, private 키워드가 붙은 메서드는 오버라이딩 할 수 없다.
<br>final - 수정할 수 없음.  static - 의미가 없음.  private - 해당 클래스에서만 접근할 수 있음. (하위 클래스에서 접근 불가)
5. 생성자(Constructor)는 오버라이딩 할 수 없다.

## 4. 상속과 접근제어
***접근제어자***

private < default < protected < public
















